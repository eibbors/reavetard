// Generated by CoffeeScript 1.3.3
(function() {
  var airmon, cli, exec, ifconfig, iwconfig,
    _this = this;

  exec = require('child_process').exec;

  cli = require('./cli');

  airmon = exports.airmon = {
    run: function(args, cb) {
      var cmd,
        _this = this;
      if (Array.isArray(args)) {
        args = args.join(' ');
      }
      if (args) {
        cmd = "airmon-ng " + args;
      } else {
        cmd = "airmon-ng";
      }
      return exec(cmd, {}, function(err, stdout, stderr) {
        var ifrow, isIfaces, line, lines, monok, oniface, proc, results, section, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
        isIfaces = false;
        results = {};
        if (err) {
          throw err;
        } else if (stdout) {
          _ref = stdout.split('\n\n');
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            section = _ref[_i];
            lines = section.split('\n');
            if (lines[0] === 'PID\tName') {
              results.processes = {};
              _ref1 = lines.slice(1);
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                line = _ref1[_j];
                proc = /(\d+)\t(\w+)/.exec(line);
                if (proc) {
                  results.processes[proc[1]] = {
                    pid: proc[1],
                    name: proc[2]
                  };
                } else {
                  oniface = /Process with PID (\d+) \((.*)\) is running on interface (.*)/.exec(line);
                  if (oniface) {
                    results.processes[oniface[1]].runningOn = oniface[3];
                  }
                }
              }
            }
            if (/Interface\tChipset\t\tDriver/g.test(section)) {
              isIfaces = true;
            } else if (isIfaces) {
              isIfaces = false;
              results.interfaces = [];
              for (_k = 0, _len2 = lines.length; _k < _len2; _k++) {
                line = lines[_k];
                ifrow = /([^\t]+)\t+([^\t]+)\t+(\w+)\s-\s\[(\w+)\](\s+\(removed\))?/.exec(line);
                if (ifrow) {
                  results.interfaces.push({
                    "interface": ifrow[1],
                    chipset: ifrow[2],
                    driver: ifrow[3],
                    phyid: ifrow[4],
                    removed: ifrow[5] === ' (removed)'
                  });
                } else {
                  monok = /\s+\(monitor mode enabled on (\w+)\)/.exec(line);
                  if (monok) {
                    results.enabledOn = monok[1];
                  }
                }
              }
            }
          }
          return cb(results, stdout, stderr);
        }
      });
    },
    getInterfaces: function(cb) {
      return this.run(void 0, function(res) {
        return cb(res.interfaces);
      });
    },
    getPhysicalInterfaces: function(cb) {
      return this.getInterfaces(function(ifaces) {
        var iface, phys, _i, _len, _name, _ref;
        phys = {};
        for (_i = 0, _len = ifaces.length; _i < _len; _i++) {
          iface = ifaces[_i];
          if ((_ref = phys[_name = iface.phyid]) == null) {
            phys[_name] = [];
          }
          phys[iface.phyid].push(iface);
        }
        return cb(phys);
      });
    },
    start: function(iface, cb, channel) {
      var cmd;
      if (channel == null) {
        channel = false;
      }
      cmd = ['start', iface];
      if (channel) {
        cmd.push(channel);
      }
      return this.run(cmd, function(res) {
        var _ref;
        if (((_ref = res.enabledOn) != null ? _ref.length : void 0) > 0) {
          res.success = true;
        } else {
          res.success = false;
        }
        return cb(res);
      });
    },
    stop: function(iface, cb) {
      return this.run(['stop', iface], function(res) {
        var _i, _len, _ref;
        res.success = false;
        _ref = res.interfaces;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          iface = _ref[_i];
          if (iface.removed) {
            res.success = true;
          }
        }
        return cb(res);
      });
    },
    check: function(cb) {
      return this.run(['check'], cb);
    },
    kill: function(cb) {
      return this.run(['check', 'kill'], cb);
    }
  };

  iwconfig = exports.iwconfig = {
    run: function(args, cb) {
      var cmd;
      if (Array.isArray(args)) {
        args = args.join(' ');
      }
      if (args) {
        cmd = "iwconfig " + args;
      } else {
        cmd = 'iwconfig';
      }
      return exec(cmd, {}, function(err, stdout, stderr) {
        var fld, flds, interfaces, iwflds, iwname, iwtmp, section, sections, _i, _j, _len, _len1;
        if (err) {
          return cb(err, false);
        }
        interfaces = [];
        sections = stdout.split(/\n\s*\n/);
        for (_i = 0, _len = sections.length; _i < _len; _i++) {
          section = sections[_i];
          iwname = /(\w+)\s+IEEE 802\.11(\w+)/.exec(section);
          iwflds = section.match(/\s\s+((\S+\s?)+)(:|=)\s?((\S+\s?)+)/g);
          if (iwname) {
            iwtmp = {
              name: iwname[1],
              supports: iwname[2].split('')
            };
            for (_j = 0, _len1 = iwflds.length; _j < _len1; _j++) {
              flds = iwflds[_j];
              fld = flds.split(/(:|=)/);
              if (fld.length > 3) {
                fld[2] = fld.slice(2).join('');
              }
              fld[0] = fld[0].replace('-', ' ').trim();
              fld[0] = fld[0].toLowerCase().replace(/(\s+\w)/g, function(m) {
                return m.trim().toUpperCase();
              });
              fld[2] = fld[2].trim();
              iwtmp[fld[0]] = fld[2];
            }
            interfaces.push(iwtmp);
          }
        }
        return cb(err, interfaces);
      });
    },
    checkWifiSetup: function(iface, cb) {
      if (iface) {
        return this.run('', function(err, interfaces) {
          var i, _i, _len;
          for (_i = 0, _len = interfaces.length; _i < _len; _i++) {
            i = interfaces[_i];
            if (i.name === iface) {
              return cb(err, i);
            }
          }
          return cb("Error: Interface " + iface + " not found!", false);
        });
      } else {
        return this.run('', cb);
      }
    }
  };

  ifconfig = exports.ifconfig = {
    run: function(args, cb) {
      var cmd;
      if (Array.isArray(args)) {
        args = args.join(' ');
      }
      if (args) {
        cmd = "ifconfig " + args;
      } else {
        cmd = 'ifconfig';
      }
      return exec(cmd, {}, function(err, stdout, stderr) {
        var attcat, attr, attrs, decl, interfaces, ischild, ismore, lastcat, lastiface, line, lines, piece, pieces, section, sections, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        if (err) {
          return cb(err, false);
        }
        interfaces = [];
        sections = stdout.split(/\n\s*\n/);
        for (_i = 0, _len = sections.length; _i < _len; _i++) {
          section = sections[_i];
          lines = section.split('\n');
          for (_j = 0, _len1 = lines.length; _j < _len1; _j++) {
            line = lines[_j];
            decl = /^(\w+)\s+Link encap:((\s?\w+)+)  (HWaddr (\S+)  )?/i.exec(line);
            if (decl) {
              if (typeof lastiface !== "undefined" && lastiface !== null) {
                interfaces.push(lastiface);
              }
              lastiface = {
                name: decl[1],
                type: decl[2],
                mac: decl[5]
              };
              decl = false;
            } else {
              pieces = line.split(/\s\s+/);
              _ref = pieces.slice(1);
              for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
                piece = _ref[_k];
                attrs = piece.match(/(RX |TX |inet |inet6 )?((\S+):\s?(\S+))+/g);
                if (((attrs != null ? attrs.length : void 0) != null) >= 1) {
                  attcat = attrs[0].split(' ');
                  if ((attcat != null ? attcat.length : void 0) === 1) {
                    ischild = /^([a-z]+):(.*)/g.exec(attcat[0]);
                    if (ischild && lastcat) {
                      lastiface[lastcat][ischild[1]] = ischild[2];
                      ismore = attrs[1].split(':');
                      if (ismore.length > 1) {
                        lastiface[lastcat][ismore[0]] = ismore[1];
                      }
                    } else {
                      attr = attcat[0].split(':');
                      lastiface[attr[0]] = attr[1];
                    }
                  } else if ((attcat != null ? attcat.length : void 0) === 2) {
                    lastcat = attcat[0];
                    attr = attcat[1].split(':');
                    if ((_ref1 = lastiface[lastcat]) == null) {
                      lastiface[lastcat] = {};
                    }
                    lastiface[lastcat][attr[0]] = attr[attr.length - 1];
                    _ref2 = attrs.slice(1);
                    for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
                      attr = _ref2[_l];
                      attr = attr.split(':');
                      lastiface[lastcat][attr[0]] = attr[attr.length - 1];
                    }
                  } else if ((attcat != null ? attcat.length : void 0) === 3) {
                    lastcat = attcat[0];
                    if ((_ref3 = lastiface[lastcat]) == null) {
                      lastiface[lastcat] = {};
                    }
                    lastiface[lastcat][attcat[1].replace(':', '')] = attcat[2];
                  }
                } else {
                  if (/([A-Z]+ ?)+/g.test(piece)) {
                    lastiface.flags = piece.split(' ');
                  }
                }
              }
            }
          }
        }
        interfaces.push(lastiface);
        return cb(err, interfaces);
      });
    },
    all: function(cb) {
      return this.run('-a', cb);
    },
    up: function(iface, cb) {
      return this.run("" + iface + " up", function(err) {
        if (err) {
          return cb(err, false);
        } else {
          return cb(null, true);
        }
      });
    },
    down: function(iface, cb) {
      return this.run("" + iface + " down", function(err) {
        if (err) {
          return cb(err, false);
        } else {
          return cb(null, true);
        }
      });
    }
  };

}).call(this);
